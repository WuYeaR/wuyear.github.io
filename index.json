[{"content":"","date":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/effective-c++/","section":"Tags","summary":"","title":"Effective C++"},{"content":"","date":null,"permalink":"/categories/effective-c++%E7%AC%94%E8%AE%B0/","section":"Categories","summary":"","title":"Effective C++笔记"},{"content":"","date":null,"permalink":"/","section":"JJWu's Tech Blog","summary":"","title":"JJWu's Tech Blog"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"条款3-尽可能使用const # const简介 # const是一个语义约束(指定一个不该被改动的对象), 而编译器会强制实施这项约束,\nconst可以在class外, 修饰global或者namespace中被声明为static的对象 可以用来修饰class内部的static和non-static成员变量 面对指针, 你可以指出指针的本身, 指针所指物, 或者两者都(或都不)是const const在指针中的应用 # char greeting[] = \u0026#34;Hello\u0026#34;; // non-const pointer, non-const data char* p = greeting; // non-const pointer, non-const data const char* p = greeting; // non-const pointer, const data char* const p = greeting; // const pointer, non-const pointer const char* const p = greeting; // const pointer, const data const在星号的左边, 表示被指物是常量, 如果出现在右边, 表示指针自身是常量, 如果出现在星号两边, 表示被指物和指针本身都是常量\n// 两种的位置都是可以的 void f1(const Widget* pw); void f2(Widge const* pw); STL的迭代器是以指针为根据设计出来, 所以迭代器的作用就像个T* 指针, 声明迭代器为const就像声明指针为const一样, 即声明一个T* const指针, 表示迭代器不得指向不同的东西, 但是它所指的值是可以改动的, 如果你希望迭代器所指的东西不可改动, 需要使用const_iterator\nstd::vector\u0026lt;int\u0026gt; vec{1}; std::vector\u0026lt;int\u0026gt;::iterator iter = vec.begin(); *iter = 10; // 可以改变iter所指物 ++iter; // 错误 不可以改变iter std::vector\u0026lt;int\u0026gt;::const_iterator cIter = vec.begin(); *cIter = 10; // 错误 *cIter是const ++cIter; // 可以改变cIter const在函数声明中的应用 # 本小节已经过时! 在C++ 11之后已经不推荐 C++ 11引入了左值和右值, 返回一个non-const value能够充分利用右值, 比如: (a + b).expensive(); Effective C++关于const返回的介绍 返回一个常量值, 往往可以降低客户错误而造成的意外, 又不至于放弃安全性和高效性, 如: class Ratianal {} const Rational operator* (const Rational\u0026amp; lhs, const Rational\u0026amp; rhs); Rational a, b, c; (a * b) = c; // 在a * b的结果上调用operator= 比如如果客户写的笔误时:\nif (a * b = c) { // 其实是想做一个==操作 } 能和内置类型一样, 直截了当的显示不合法\nconst在成员函数中的应用 # const成员函数的目的是让该成员函数可以作用于const对象 ·const·成员函数的重要作用有两个:\n使得class的接口容易被理解, 这是因为得知哪个函数可以改动对象内容而哪个函数不行, 很是重要\n使得操作const对象成为可能\n提高代码效率的方式, pass by reference-to-const的方式传递对象, 需要有const成员函数可以处理const对象\n类可以设计两个成员函数, 一个用来处理non-const对象, 一个用来处理const对象, 它们是重载 class TextBlock { public: const char\u0026amp; operator[](std::size_t position) { return text[position]; } const char\u0026amp; operator[](std::size_t position) const { return text[position]; } }; ","date":"2023年3月5日","permalink":"/posts/effective-c++%E7%AC%94%E8%AE%B0/2023-03-05-%E6%9D%A1%E6%AC%BE3-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/","section":"Posts","summary":"条款3-尽可能使用const # const简介 # const是一个语义约束(指定一个不该被改动的对象), 而编译器会强制实施这项约束,","title":"条款3-尽可能使用const"},{"content":"","date":null,"permalink":"/tags/%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"学习"},{"content":"尽量以const, enum, inline替换#define # 为什么要替换#define # 假设有存在一个定义\n#define PI_M 3.1415 PI_M在编译前就被预处理器移走了, 所以从未进入过symbol table, 如果在使用变量但是出现编译期错误信息时, 提到的是3.1415而不是PI_M 同理在symbol debugger中也可能因为没有进入symbol table而为了追踪它浪费时间 使用#define可能会因为预处理器盲目的将PI_M替换而导致3.1415在object code中出现多次 用常量替换宏 # #define PI_M 3.1415 // 使用常量来代替宏(#define) const double PI_M = 3.1415; 对于指针的使用需要注意*******前后的const\nconst char* authorName = \u0026#34;JJWu\u0026#34;; // 指向一个字符常量, 不可以改变字符的内容 char* const authorName = \u0026#34;JJWu\u0026#34;; // 常量指针, 不可以指向其他字符 const char* const authorName = \u0026#34;JJWu\u0026#34;; // 指向常量字符的常量指针 注意: C++98中规定, 在命名空间 namespace中的const是隐式static的 关于static与extern的对比 Translation unit: A source file after the pre-processor (recursively) included all its include files. static linkage: A symbol is only available within its translation unit. ernal linkage: A symbol is available from other translation units.\nstatic const int sci = 0; // sci is explicitly static const int ci = 1; // ci is implicitly static extern const int eci = 2; // eci is explicitly extern extern int ei = 3; // ei is explicitly extern int i = 4; // i is implicitly extern static int si = 5; // si is explicitly static 在类中用enum替换宏 # 为了将常量的作用域scope限制于class中, 你必须让它成为class的一个成员member, 为了确保这个常量只有一份实体, 必须要成为一个static的成员:\nclass GamePlayer{ private: static const int numTurns = 4; // 常量声明式 int scores[numTurns]; // 使用该常量 public: static void printf() { cout \u0026lt;\u0026lt; \u0026amp;numTurns \u0026lt;\u0026lt; endl; } }; numTurns是一个声明式, 通常来说C++要求你对你所使用的东西提供一个_定义式_, 但是如果变量是一个class成员, 且是static且类型是整数类型(如int char bool), 我们可以声明并使用而不用提供定义式\n但是, 当我们尝试获取它的地址时, 我们必须提供他的定义式:\nconst int GamePlaer::numTurns;// 因为在声明时将它的初值设为4, 所以不用提供初值 类的专属变量无法使用#define的方式来定义, 因为#define不重视scope作用域, 一旦宏被定义, 在后续的使用中都是有效的, 除非被#undef\n如果旧版本的编译期不支持上述的做法static成员在其声明式上获得初值, 此外所谓的in-class 初值设定也只允许对整数常量进行\n如果不支持, 则只能通过如下方式进行:\nclass CostEstimate { private: static const double FudgeFactor;// static class常量声明 } const double CostEstimate::FudgeFactor = 1.35;//static class常量定义 如果需要在编译期提供一个class常量值, 例如GamePlayer::scores的数组声明式, 如果编译期不支持~~static整数型class常量完成in class初值设定~~, 可以使用the enum hack的补偿方法\nthe enum hack比较像#define而不是const, 例如取一个const的地址是合法的, 但是取一个enum和#define的地址是不合法, 另外不够聪明的编译器, 也可能给const变量分配额外的内存, enum和#define绝对不会\nenum hack是很实用的, enum hack是template metaprogramming的基础技术\n如果你不想让别人获得一个pointer或者reference指向你的某个整数常量, enum可以帮助你实现这个约束\n替换宏函数 # #define另外一个常用的实现宏macros, 宏看起来像是函数, 但是不会导致函数调用带来额外的开销\n#define CALL_WITH_MAX(a, b) f((a) \u0026gt; (b) ? (a) : (b)) // 缺点, 调用f之前, a累加的次数竟然取决于\u0026#34;a被拿来和谁比较\u0026#34; int a = 5, b = 0; CALL_WITH_MAX(++a, b); // a被累加2次 CALL_WITH_MAX(++a, b + 10); // a被累加1次 另外一个麻烦的是必须要为宏参数中的所有实参加上小括号, 否则可能会出现问题\n解决宏的方法就是template inline 函数\ntemplate inline 函数具有宏的效率以及一般函数的所有可预料行为和类型安全性type safety\n一个template inline 函数如下所示:\ntemplate\u0026lt;typename T\u0026gt; inline void callWithMax(const T\u0026amp; a, const T\u0026amp;b) { f(a \u0026gt; b ? a : b); } 具备优点:\n不需要在函数本体中为参数加上括号\n不需要操心参数被核算(求值)多次\n遵守作用域scope和访问规则, 例如可以写一个class 类的private inline函数\n总结 # 对于单纯常量, 最好以const对象或者enum来代替#define\n对于形似函数的宏, 最好改用inline函数来替代#define\n","date":"2023年2月27日","permalink":"/posts/effective-c++%E7%AC%94%E8%AE%B0/2023-02-27-%E6%9D%A1%E6%AC%BE2-%E6%9B%BF%E6%8D%A2define/","section":"Posts","summary":"尽量以const, enum, inline替换#define # 为什么要替换#define # 假设有存在一个定义","title":"条款2: 替换define"},{"content":"视C++为一个联邦 # 1. C与C++ # C以C++为基础 Object-Oriented C++ templates STL 2. C++是一门多重泛型的语言 # 过程形式(procedural) 面向对象形式(object-oriented) 泛型形式(generic) 元编程形式(metaprogramming) 函数形式(functional) C++是一门语言的联邦而不是一个单独的语言, 他是四个次级语言组成的___联邦___, 每个次语言都有自己的规约 # 比如在内置类型C like而言, pass-by-value通常更高效, 但是到了Object-Oriented, 由于构造和析构的存在, pass-by-reference-const往往更好, template C++更是如此, 因为在展开前, 你不知道所处理的对象的类型, 但是, 到了STL迭代器和数组而言, pass-by-value再次适用 所以, 每个次语言都有自己的规约, 不要惊讶\n","date":"2023年2月27日","permalink":"/posts/effective-c++%E7%AC%94%E8%AE%B0/2023-02-27-%E6%9D%A1%E6%AC%BE1-%E8%A7%86c++%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%81%94%E9%82%A6/","section":"Posts","summary":"视C++为一个联邦 # 1.","title":"条款1: 视C++为一个联邦"},{"content":" 安装zsh包 # sudo apt install zsh 安装Oh My Zsh框架 # sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 推荐插件 # Powerlevel10k # git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k exec zsh p10k configure zsh-syntax-highlighting # git clone --depth=1 https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting zsh-autosuggestions # git clone --depth=1 https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions z.lua # git clone --depth=1 https://github.com/skywind3000/z.lua.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/z.lua autoupdate-zsh-plugin # git clone --depth=1 https://github.com/TamCore/autoupdate-oh-my-zsh-plugins $ZSH_CUSTOM/plugins/autoupdate .zshrc配置 # ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; plugins=(sudo git z.lua extract command-not-found autoupdate zsh-autosuggestions zsh-syntax-highlighting) ","date":"2023年2月26日","permalink":"/posts/2023-02-26-linux%E9%85%8D%E7%BD%AE/","section":"Posts","summary":"安装zsh包 # sudo apt install zsh 安装Oh My Zsh框架 # sh -c \u0026#34;$(curl -fsSL https://raw.","title":"Linux 配置"},{"content":"","date":null,"permalink":"/tags/linux%E9%85%8D%E7%BD%AE/","section":"Tags","summary":"","title":"Linux配置"},{"content":"","date":null,"permalink":"/tags/zsh/","section":"Tags","summary":"","title":"zsh"},{"content":"","date":null,"permalink":"/tags/%E7%BE%8E%E5%8C%96/","section":"Tags","summary":"","title":"美化"},{"content":"","date":null,"permalink":"/categories/%E7%BE%8E%E5%8C%96/","section":"Categories","summary":"","title":"美化"},{"content":"","date":null,"permalink":"/categories/%E9%85%8D%E7%BD%AE/","section":"Categories","summary":"","title":"配置"}]